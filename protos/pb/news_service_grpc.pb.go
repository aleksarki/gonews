// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.2
// source: news_service.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SaveService_CreateUser_FullMethodName         = "/news.SaveService/CreateUser"
	SaveService_SaveNews_FullMethodName           = "/news.SaveService/SaveNews"
	SaveService_GetNewsByIDs_FullMethodName       = "/news.SaveService/GetNewsByIDs"
	SaveService_AddFavourite_FullMethodName       = "/news.SaveService/AddFavourite"
	SaveService_GetFavourites_FullMethodName      = "/news.SaveService/GetFavourites"
	SaveService_AddToSearchHistory_FullMethodName = "/news.SaveService/AddToSearchHistory"
	SaveService_GetSearchHistory_FullMethodName   = "/news.SaveService/GetSearchHistory"
	SaveService_Subscribe_FullMethodName          = "/news.SaveService/Subscribe"
	SaveService_GetSubscriptions_FullMethodName   = "/news.SaveService/GetSubscriptions"
)

// SaveServiceClient is the client API for SaveService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Save Service
type SaveServiceClient interface {
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
	SaveNews(ctx context.Context, in *SaveNewsRequest, opts ...grpc.CallOption) (*SaveNewsResponse, error)
	GetNewsByIDs(ctx context.Context, in *GetNewsByIDsRequest, opts ...grpc.CallOption) (*GetNewsByIDsResponse, error)
	AddFavourite(ctx context.Context, in *AddFavouriteRequest, opts ...grpc.CallOption) (*AddFavouriteResponse, error)
	GetFavourites(ctx context.Context, in *GetFavouritesRequest, opts ...grpc.CallOption) (*GetFavouritesResponse, error)
	AddToSearchHistory(ctx context.Context, in *AddToSearchHistoryRequest, opts ...grpc.CallOption) (*AddToSearchHistoryResponse, error)
	GetSearchHistory(ctx context.Context, in *GetSearchHistoryRequest, opts ...grpc.CallOption) (*GetSearchHistoryResponse, error)
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error)
	GetSubscriptions(ctx context.Context, in *GetSubscriptionsRequest, opts ...grpc.CallOption) (*GetSubscriptionsResponse, error)
}

type saveServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSaveServiceClient(cc grpc.ClientConnInterface) SaveServiceClient {
	return &saveServiceClient{cc}
}

func (c *saveServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUserResponse)
	err := c.cc.Invoke(ctx, SaveService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *saveServiceClient) SaveNews(ctx context.Context, in *SaveNewsRequest, opts ...grpc.CallOption) (*SaveNewsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveNewsResponse)
	err := c.cc.Invoke(ctx, SaveService_SaveNews_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *saveServiceClient) GetNewsByIDs(ctx context.Context, in *GetNewsByIDsRequest, opts ...grpc.CallOption) (*GetNewsByIDsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNewsByIDsResponse)
	err := c.cc.Invoke(ctx, SaveService_GetNewsByIDs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *saveServiceClient) AddFavourite(ctx context.Context, in *AddFavouriteRequest, opts ...grpc.CallOption) (*AddFavouriteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddFavouriteResponse)
	err := c.cc.Invoke(ctx, SaveService_AddFavourite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *saveServiceClient) GetFavourites(ctx context.Context, in *GetFavouritesRequest, opts ...grpc.CallOption) (*GetFavouritesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFavouritesResponse)
	err := c.cc.Invoke(ctx, SaveService_GetFavourites_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *saveServiceClient) AddToSearchHistory(ctx context.Context, in *AddToSearchHistoryRequest, opts ...grpc.CallOption) (*AddToSearchHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddToSearchHistoryResponse)
	err := c.cc.Invoke(ctx, SaveService_AddToSearchHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *saveServiceClient) GetSearchHistory(ctx context.Context, in *GetSearchHistoryRequest, opts ...grpc.CallOption) (*GetSearchHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSearchHistoryResponse)
	err := c.cc.Invoke(ctx, SaveService_GetSearchHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *saveServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubscribeResponse)
	err := c.cc.Invoke(ctx, SaveService_Subscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *saveServiceClient) GetSubscriptions(ctx context.Context, in *GetSubscriptionsRequest, opts ...grpc.CallOption) (*GetSubscriptionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSubscriptionsResponse)
	err := c.cc.Invoke(ctx, SaveService_GetSubscriptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SaveServiceServer is the server API for SaveService service.
// All implementations must embed UnimplementedSaveServiceServer
// for forward compatibility.
//
// Save Service
type SaveServiceServer interface {
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
	SaveNews(context.Context, *SaveNewsRequest) (*SaveNewsResponse, error)
	GetNewsByIDs(context.Context, *GetNewsByIDsRequest) (*GetNewsByIDsResponse, error)
	AddFavourite(context.Context, *AddFavouriteRequest) (*AddFavouriteResponse, error)
	GetFavourites(context.Context, *GetFavouritesRequest) (*GetFavouritesResponse, error)
	AddToSearchHistory(context.Context, *AddToSearchHistoryRequest) (*AddToSearchHistoryResponse, error)
	GetSearchHistory(context.Context, *GetSearchHistoryRequest) (*GetSearchHistoryResponse, error)
	Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error)
	GetSubscriptions(context.Context, *GetSubscriptionsRequest) (*GetSubscriptionsResponse, error)
	mustEmbedUnimplementedSaveServiceServer()
}

// UnimplementedSaveServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSaveServiceServer struct{}

func (UnimplementedSaveServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedSaveServiceServer) SaveNews(context.Context, *SaveNewsRequest) (*SaveNewsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveNews not implemented")
}
func (UnimplementedSaveServiceServer) GetNewsByIDs(context.Context, *GetNewsByIDsRequest) (*GetNewsByIDsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNewsByIDs not implemented")
}
func (UnimplementedSaveServiceServer) AddFavourite(context.Context, *AddFavouriteRequest) (*AddFavouriteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddFavourite not implemented")
}
func (UnimplementedSaveServiceServer) GetFavourites(context.Context, *GetFavouritesRequest) (*GetFavouritesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetFavourites not implemented")
}
func (UnimplementedSaveServiceServer) AddToSearchHistory(context.Context, *AddToSearchHistoryRequest) (*AddToSearchHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddToSearchHistory not implemented")
}
func (UnimplementedSaveServiceServer) GetSearchHistory(context.Context, *GetSearchHistoryRequest) (*GetSearchHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSearchHistory not implemented")
}
func (UnimplementedSaveServiceServer) Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedSaveServiceServer) GetSubscriptions(context.Context, *GetSubscriptionsRequest) (*GetSubscriptionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSubscriptions not implemented")
}
func (UnimplementedSaveServiceServer) mustEmbedUnimplementedSaveServiceServer() {}
func (UnimplementedSaveServiceServer) testEmbeddedByValue()                     {}

// UnsafeSaveServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SaveServiceServer will
// result in compilation errors.
type UnsafeSaveServiceServer interface {
	mustEmbedUnimplementedSaveServiceServer()
}

func RegisterSaveServiceServer(s grpc.ServiceRegistrar, srv SaveServiceServer) {
	// If the following call panics, it indicates UnimplementedSaveServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SaveService_ServiceDesc, srv)
}

func _SaveService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SaveServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SaveService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SaveServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SaveService_SaveNews_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveNewsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SaveServiceServer).SaveNews(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SaveService_SaveNews_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SaveServiceServer).SaveNews(ctx, req.(*SaveNewsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SaveService_GetNewsByIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNewsByIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SaveServiceServer).GetNewsByIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SaveService_GetNewsByIDs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SaveServiceServer).GetNewsByIDs(ctx, req.(*GetNewsByIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SaveService_AddFavourite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddFavouriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SaveServiceServer).AddFavourite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SaveService_AddFavourite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SaveServiceServer).AddFavourite(ctx, req.(*AddFavouriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SaveService_GetFavourites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFavouritesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SaveServiceServer).GetFavourites(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SaveService_GetFavourites_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SaveServiceServer).GetFavourites(ctx, req.(*GetFavouritesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SaveService_AddToSearchHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddToSearchHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SaveServiceServer).AddToSearchHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SaveService_AddToSearchHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SaveServiceServer).AddToSearchHistory(ctx, req.(*AddToSearchHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SaveService_GetSearchHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSearchHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SaveServiceServer).GetSearchHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SaveService_GetSearchHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SaveServiceServer).GetSearchHistory(ctx, req.(*GetSearchHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SaveService_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SaveServiceServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SaveService_Subscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SaveServiceServer).Subscribe(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SaveService_GetSubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubscriptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SaveServiceServer).GetSubscriptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SaveService_GetSubscriptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SaveServiceServer).GetSubscriptions(ctx, req.(*GetSubscriptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SaveService_ServiceDesc is the grpc.ServiceDesc for SaveService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SaveService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "news.SaveService",
	HandlerType: (*SaveServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _SaveService_CreateUser_Handler,
		},
		{
			MethodName: "SaveNews",
			Handler:    _SaveService_SaveNews_Handler,
		},
		{
			MethodName: "GetNewsByIDs",
			Handler:    _SaveService_GetNewsByIDs_Handler,
		},
		{
			MethodName: "AddFavourite",
			Handler:    _SaveService_AddFavourite_Handler,
		},
		{
			MethodName: "GetFavourites",
			Handler:    _SaveService_GetFavourites_Handler,
		},
		{
			MethodName: "AddToSearchHistory",
			Handler:    _SaveService_AddToSearchHistory_Handler,
		},
		{
			MethodName: "GetSearchHistory",
			Handler:    _SaveService_GetSearchHistory_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _SaveService_Subscribe_Handler,
		},
		{
			MethodName: "GetSubscriptions",
			Handler:    _SaveService_GetSubscriptions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "news_service.proto",
}

const (
	SearchService_SearchNews_FullMethodName       = "/news.SearchService/SearchNews"
	SearchService_GetTopHeadlines_FullMethodName  = "/news.SearchService/GetTopHeadlines"
	SearchService_CheckNewArticles_FullMethodName = "/news.SearchService/CheckNewArticles"
)

// SearchServiceClient is the client API for SearchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Search Service
type SearchServiceClient interface {
	SearchNews(ctx context.Context, in *SearchNewsRequest, opts ...grpc.CallOption) (*SearchNewsResponse, error)
	GetTopHeadlines(ctx context.Context, in *GetTopHeadlinesRequest, opts ...grpc.CallOption) (*GetTopHeadlinesResponse, error)
	CheckNewArticles(ctx context.Context, in *CheckNewArticlesRequest, opts ...grpc.CallOption) (*CheckNewArticlesResponse, error)
}

type searchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSearchServiceClient(cc grpc.ClientConnInterface) SearchServiceClient {
	return &searchServiceClient{cc}
}

func (c *searchServiceClient) SearchNews(ctx context.Context, in *SearchNewsRequest, opts ...grpc.CallOption) (*SearchNewsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchNewsResponse)
	err := c.cc.Invoke(ctx, SearchService_SearchNews_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) GetTopHeadlines(ctx context.Context, in *GetTopHeadlinesRequest, opts ...grpc.CallOption) (*GetTopHeadlinesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTopHeadlinesResponse)
	err := c.cc.Invoke(ctx, SearchService_GetTopHeadlines_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) CheckNewArticles(ctx context.Context, in *CheckNewArticlesRequest, opts ...grpc.CallOption) (*CheckNewArticlesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckNewArticlesResponse)
	err := c.cc.Invoke(ctx, SearchService_CheckNewArticles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SearchServiceServer is the server API for SearchService service.
// All implementations must embed UnimplementedSearchServiceServer
// for forward compatibility.
//
// Search Service
type SearchServiceServer interface {
	SearchNews(context.Context, *SearchNewsRequest) (*SearchNewsResponse, error)
	GetTopHeadlines(context.Context, *GetTopHeadlinesRequest) (*GetTopHeadlinesResponse, error)
	CheckNewArticles(context.Context, *CheckNewArticlesRequest) (*CheckNewArticlesResponse, error)
	mustEmbedUnimplementedSearchServiceServer()
}

// UnimplementedSearchServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSearchServiceServer struct{}

func (UnimplementedSearchServiceServer) SearchNews(context.Context, *SearchNewsRequest) (*SearchNewsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchNews not implemented")
}
func (UnimplementedSearchServiceServer) GetTopHeadlines(context.Context, *GetTopHeadlinesRequest) (*GetTopHeadlinesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTopHeadlines not implemented")
}
func (UnimplementedSearchServiceServer) CheckNewArticles(context.Context, *CheckNewArticlesRequest) (*CheckNewArticlesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckNewArticles not implemented")
}
func (UnimplementedSearchServiceServer) mustEmbedUnimplementedSearchServiceServer() {}
func (UnimplementedSearchServiceServer) testEmbeddedByValue()                       {}

// UnsafeSearchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SearchServiceServer will
// result in compilation errors.
type UnsafeSearchServiceServer interface {
	mustEmbedUnimplementedSearchServiceServer()
}

func RegisterSearchServiceServer(s grpc.ServiceRegistrar, srv SearchServiceServer) {
	// If the following call panics, it indicates UnimplementedSearchServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SearchService_ServiceDesc, srv)
}

func _SearchService_SearchNews_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchNewsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchNews(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_SearchNews_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchNews(ctx, req.(*SearchNewsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_GetTopHeadlines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopHeadlinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).GetTopHeadlines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_GetTopHeadlines_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).GetTopHeadlines(ctx, req.(*GetTopHeadlinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_CheckNewArticles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckNewArticlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).CheckNewArticles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_CheckNewArticles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).CheckNewArticles(ctx, req.(*CheckNewArticlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SearchService_ServiceDesc is the grpc.ServiceDesc for SearchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SearchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "news.SearchService",
	HandlerType: (*SearchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchNews",
			Handler:    _SearchService_SearchNews_Handler,
		},
		{
			MethodName: "GetTopHeadlines",
			Handler:    _SearchService_GetTopHeadlines_Handler,
		},
		{
			MethodName: "CheckNewArticles",
			Handler:    _SearchService_CheckNewArticles_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "news_service.proto",
}

const (
	NotificationService_SendNotification_FullMethodName = "/news.NotificationService/SendNotification"
)

// NotificationServiceClient is the client API for NotificationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Notification Service
type NotificationServiceClient interface {
	SendNotification(ctx context.Context, in *SendNotificationRequest, opts ...grpc.CallOption) (*SendNotificationResponse, error)
}

type notificationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationServiceClient(cc grpc.ClientConnInterface) NotificationServiceClient {
	return &notificationServiceClient{cc}
}

func (c *notificationServiceClient) SendNotification(ctx context.Context, in *SendNotificationRequest, opts ...grpc.CallOption) (*SendNotificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendNotificationResponse)
	err := c.cc.Invoke(ctx, NotificationService_SendNotification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationServiceServer is the server API for NotificationService service.
// All implementations must embed UnimplementedNotificationServiceServer
// for forward compatibility.
//
// Notification Service
type NotificationServiceServer interface {
	SendNotification(context.Context, *SendNotificationRequest) (*SendNotificationResponse, error)
	mustEmbedUnimplementedNotificationServiceServer()
}

// UnimplementedNotificationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNotificationServiceServer struct{}

func (UnimplementedNotificationServiceServer) SendNotification(context.Context, *SendNotificationRequest) (*SendNotificationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendNotification not implemented")
}
func (UnimplementedNotificationServiceServer) mustEmbedUnimplementedNotificationServiceServer() {}
func (UnimplementedNotificationServiceServer) testEmbeddedByValue()                             {}

// UnsafeNotificationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationServiceServer will
// result in compilation errors.
type UnsafeNotificationServiceServer interface {
	mustEmbedUnimplementedNotificationServiceServer()
}

func RegisterNotificationServiceServer(s grpc.ServiceRegistrar, srv NotificationServiceServer) {
	// If the following call panics, it indicates UnimplementedNotificationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NotificationService_ServiceDesc, srv)
}

func _NotificationService_SendNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).SendNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_SendNotification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).SendNotification(ctx, req.(*SendNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NotificationService_ServiceDesc is the grpc.ServiceDesc for NotificationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NotificationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "news.NotificationService",
	HandlerType: (*NotificationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendNotification",
			Handler:    _NotificationService_SendNotification_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "news_service.proto",
}
